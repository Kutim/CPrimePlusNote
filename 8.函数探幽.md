#  1. C++ 内联函数

​	为 C++提高程序运行速度所做的一项改进。与常规函数的区别在于编译器如何将它们组合到程序中。

​	常规函数使程序跳到另一个地址（函数地址），并在函数结束时返回。执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈，跳到标记函数起点的内存单元，执行函数代码，然后跳回到地址被保存的指令处。

​	编译器将内联函数相应的函数代码替换函数调用。内联函数的运行速度比常规函数稍快，代价是需要占用更多内存。

​	应有选择的使用内联函数。如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很小一部分。如果代码执行时间很短，则内联函数就可以节省非内联调用使用的大部分时间。另一方面，由于这个过程相当快，因此尽管节省了该过程的大部分时间，但节省的时间绝对值并不大，除非该函数经常被调用。

​	要使用内联函数，必须采取下述措施之一：

- 在函数声明前加上关键字inline；
- 在函数定义前加上关键字inline；

  ​通常的做法是省略声明，将定义放在本应提供声明的地方。

  ​编译器不一定满足程序员将函数作为内联函数的要求。它可能认为该函数过大或注意到函数调用自己（内联函数不能递归），因此不将其作为内联函数。

  ​内联函数和常规函数一样，按值来传递参数。这使得C++的内敛功能远胜于 C 语言的宏定义（文本替换）。

# 2. 引用变量

​	C++新增了一种复合类型——引用变量。引用是已定义变量的别名。主要用途是用作函数的参数，这样函数将使用原始数据，而不是副本。

## 2.1 创建引用变量

​	C和C++使用&符号来指示变量的地址。C++给& 符号赋予另一个含义，将其用来声明引用。

```c++
int rats;
int & rodents = rats;  // int & 指的是指向 int 的引用

// rats 和 rodents 指向相同的值和内存单元
```

​	下面rodents 和 *prats 都可以和rats 互换，而表达式&rodents 和 prats 都可以同 &rats 互换。从这里讲，引用看上去很想指针。实际上是不同的，例如，必须在声明引用时将其初始化，而不能像指针那样，先声明，在赋值。可以通过初始化声明来设置引用，但不能通过赋值来设置，这样只能改变原来的值。

```c++
int rats = 101;
int & rodents = rats; // rodents a reference 
int * prats = &rats; // prats a pointer
```

​	引用更接近 const 指针，必须在创建时进行初始化，一旦与某个变量关联就一致效忠它。

```c++
int & rodents = rats;
int * const pr = &rats;
```

## 2.2 将引用用作函数参数

​	引用传递：将引用用作函数参数，使用函数中变量名成为调用程序中的变量的别名。

## 2.3 引用的属性和特别之处

​	如果想让函数使用传递给它的信息，而不对这些信息进行修改，同时又想使用引用，则应使用常量引用（double recube（const double &ra））。按理说这里使用按值传递即可，但使用引用时，会减少拷贝。

​	传递给引用的限制更严格。

​	如果实参与引用参数不匹配，C++将生成临时变量。当前，仅当参数为 const 引用时，C++才允许这样做，编译器将在下面两种情况下生成临时变量：

- 实参的类型正确，但不是左值（可被引用的数据对象）；
- 实参的类型不正确，但可以转换为正确的类型。

​        简而言之，如果接受引用参数的函数的意图是修改作为参数传递的变量，则创建临时变量将组织这种意图的实现。解决的方法时，禁止创建临时变量，现在的 C++标准正式这样做的。

​	应尽可能的使用 const，将引用参数声明为常量数据的引用的理由有三个：

- 使用const 可以避免无意中修改数据的编程错误；
- 使用const使用函数能够处理 const 和非 const 实参，否则只能接受非const数据；
- 使用const 引用使函数能够正确生成并使用临时变量。



​	C++11 新增了另一种引用——右值引用。这种引用可能指向右值，使用 && 声明。主要让库设计人员能够提供游侠操作的更有效实现。在18章讨论使用右值引用实现移动语义。

## 2.4 将引用用于结构

​	引入引用主要是为了用于结构和类，使用引用参数的方式与使用基本变量引用相同，只需在声明结构参数时使用引用运算符 & 即可。

​	函数返回引用可以提高效率。

​	返回引用时需要注意，避免返回函数终止时不再存在的内存单元的引用。

​	在赋值表达式中，左边的子表达式必须标识一个可修改的内存块。

## 2.5 将引用用于类对象

​	将类对象传递给函数时，C++ 通常的做法是使用引用。

​	将C- 风格字符串用作 string 对象引用参数。

- string类定义了一种 char * 到 string 的转换功能，这使得可以使用 C-风格字符串来初始化string对象。
- 讨论过的 const 引用的形参的一个属性。实参类型与引用参数类型不匹配，但可以被转换为引用类型，程序将创建一个正确类型的临时变量，使用转换后的实参值来初始化它，然后传递一个指向该临时变量的引用。

## 2.6 对象、继承和引用

​	继承的另一个特征是，基类引用可以指向派生类对象，而无需进行强制类型转换。这种特征的一个实际结果是，可以定义一个接受基类引用作为参数的函数，调用该函数时，可以将基类对象作为参数，也可以将派生类对象最为参数。

## 2.7 使用引用参数的时机

​	使用引用参数的主要原因有两个：

- 程序员能够修改调用函数中的数据对象；

- 通过传递引用而不是整个数据对象，可以提高程序的运行速度。

  何时使用引用，何时使用指针，何时使用值传递？

  对于使用传递的值不作修改的函数：

- 如果数据对象很小，则按值传递；

- 如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向 const 的指针；

- 如果数据对象是较大的结构，使用 const指针或const 引用，以提高程序效率；

- 如果数据对象是类对象，则使用 const 引用。

  ​

  对于修改调用函数中数据的函数：

- 如果数据对象是内置数据类型，则使用指针；

- 如果数据对象是数组，则只能使用指针；

- 如果数据对象是结构，则使用引用或指针；

- 如果数据对象是类对象，则使用引用。

# 3. 默认参数

​	函数调用中省略实参时自动启用的一个值。

​	编译器通过查看原型来了解函数所使用的参数数目，因此函数原型也必须将可能的默认参数告知程序。方法是将值赋给原型中的参数。

​	对于带参数列表的函数，必须从右向左添加默认值。也就是说，要为某个参数设置默认值，则必须为它右边的所有参数提供默认值。

# 4. 函数重载

​	使用多个同名的函数。

​	函数重载的关键是函数的参数列表——函数特征标（function signature）

​	编译器在检查函数特征标时，将把类型引用和类型本身视为同一特征标。函数匹配时，并不区分const 和 非const 变量——将非const 值赋给const 变量是合法的，反之是非法的。

​	关于重载的左值（&）、const、右值（&&），调用最匹配的版本。

​	当函数基本上执行相同的任务，但使用不同形式的数据时，才应该采用函数重载。

​	编译器内部使用名称修饰来追踪函数

# 5. 函数模板

​	通用的函数描述，也就是说，使用泛型来定义函数，其中的泛型可用具体的类型替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。

```c++
template <typename AnyType>			// 可以使用 class 代替 typename  与 typename 等价，大量的库中使用 class
void Swap(AnyType &a, AnyType &b) {
	AnyType temp; temp = a;
	a = b;
	b = temp;
}
```

​	调用时，直接使用函数即可。

​	函数模板不能缩短可执行程序。最终的代码不包含任何模板，而只包含为了程序生成的实际函数，使用模板的好处是，它使生成多个函数定义更简单、更可靠。

​	更常见的情形是，将模板放在头文件中，并在需要使用模板的文件中包含头文件。

## 5.1 重载的模板

​	与常规重载一样，被重载的模板的函数特征标必须不同。

## 5.2 模板的局限性

​	编写的模板函数很可能无法处理某些类型。

## 5.3 显式具体化

1. ​	第三代具体化（ISO/ANSI C++ 标准）

   C++98标准选择下面的方法：

   - 对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本；
   - 显式具体化的原型和定义应该以 template<> 打头，并通过名称来指出类型；
   - 具体化优先于常规模板，而非模板函数优先于具体化和常规模板。

   ```c++
   // non template function prototype 
   void Swap(job &, job &);

   // template prototype 
   template <typename T> void Swap(T &, T &);

   // explicit specialization for the job type 
   template <> void Swap<job>(job &, job &);
   // 也可以 有参数推断类型，进行简化
   // template <> void Swap(job &, job &); // simpler form
   ```

## 5.4 实例化与具体化

​	模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。

​	编译器使用模板为特定类型生成函数定义时，得到的是模板实例。

​	隐式实例化（编译器根据类型）、显示实例化（显示指定类型）。

​	显示实例化(使用模板生成函数定义)：

```c++
template void Swap<int>(int, int); // explicit instantiation
```

​	显示具体化(指示使用专门 显式定义的函数定义)：

```c++
template <> void Swap<int>(int &, int &); // explicit specialization 
template <> void Swap(int &, int &); // explicit specialization
```

​	试图在同一个文件（或转换单元）中使用同一种类型的显示实例和显式具体化将出错。

​	隐式实例化、显示实例化和显式具体化统称为具体化。相同之处在于，它们表示的都是使用具体类型的函数定义。

## 5.5 编译器选择使用哪个函数版本

​	对于函数重载、函数模板和函数模板重载，C++ 需要一个定义良好的策略，来决定为函数调用使用哪一个函数定义，尤其是有多个参数时，这个过程称为重载解析。

1. 创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数；
2. 使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括实参数类型与相应的形参类型完全匹配的情况（如 float 转 double）。
3. 确定是否有最佳的可行函数。最佳到最差的顺序
   - 完全匹配，但常规函数优先于模板；
   - 提升转换（如char 转 int  ，float 转 double）；
   - 标准转换（int 转char， long转double）；
   - 用户定义的转换。


1. 完全匹配和最佳匹配：

   进行完全匹配时，C++允许某些“无关紧要的转换”：(注意：Type 可以是char & 这样的类型)

   | 从实参                             | 到形参                               |
   | ------------------------------- | --------------------------------- |
   | Type                            | Type &                            |
   | Type &                          | Type                              |
   | Type []                         | * Type                            |
   | Type(argument-list)  - 用作实参的函数名 | Type(*)(argument-list) -用作形参的函数指针 |
   | Type                            | const Type                        |
   | Type                            | volatile Type                     |
   | Type *                          | const Type                        |
   | Type *                          | volatile Type *                   |

   有时，即使两个函数都完全匹配，仍可完成重载解析。指向非const 数据的指针和引用 优先与 非 const 指针和引用参数匹配。const 和 非const 之间的区别只适用于指针和引用指向的数据。

   一个完全匹配优于另一个的另一种情况是，其中一个是非模板函数，而另一个不是。这种情况下，非模板函数将优先于模板函数（包括显示具体化）。

   如果两个完全匹配的函数都是模板函数，则较为具体（编译器推断时转换少）的模板函数优先。例如，者意味着显示具体化将优先于使用模板隐式生成的具体化。



## 5.6 模板函数的发展

1. 是什么类型

   在 C++98 中，编写模板函数时，一个问题是并非总能知道应在声明中使用哪种类型。（类型提升）

2. 关键字 decltype （C++11）

   ```c++
   int x;
   decltype(x) y; // make y the same type as x

   decltype(x + y) xpy; // make xpy the same type as x + y 
   xpy = x + y;


   template<class T1, class T2> void ft(T1 x, T2 y)
   {
   ...
   decltype(x + y) xpy = x + y; ...
   }
   ```

   ​

3. 另一种函数声明语法（C++11 后置返回类型）

   ```c++
   template<class T1, class T2> 
   ?type? gt(T1 x, T2 y)
   {
   ...
   return x + y; 
   }


   template<class T1, class T2>
   auto gt(T1 x, T2 y) -> decltype(x + y) {
   ...
   return x + y; 
   }// 现在， decltype 在参数声明后面，因此 x 和 y 位于作用域内

   ```

   ​

