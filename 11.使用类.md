#  1. 运算符重载

​	C++允许将运算符重载扩展到用户定义的类型。

​	要重载运算符，需使用被称为运算符函数的特殊函数形式。运算符函数的格式如下：

```c++
operatorop(argument-list) // op 必须是有效的 C++运算符
// operator+()
// operator*() 
```

# 2.重载示例

## 2.2 重载限制

​	C++对用户定义的运算符重载的限制：

- 重载后的运算符必须至少有一个操作数时用户定义的类型，这将防止用户为标准类型重载运算符；
- 使用运算符时，不能违反运算符原有的句法规则；
- 不能创建新运算符；
- 不能重载下面的运算符
  - sizeof : sizeof 运算符；
  - . ：成员运算符；
  - .*：成员指针运算符；
  - :: ：作用域解析运算符；
  - ？: : 条件运算符；
  - typeid：一个RTTI 运算符；
  - const_cast：强制类型转换运算符；
  - dynamic_cast：强制类型转换运算符；
  - reinterpret_cast：强制类型转换运算符；
  - static_cast：强制类型转换运算符。



​	下表中的大多数运算符都可以通过成员或非成员函数进行重载，但下面运算符只能通过成员函数进行重载：

- = ：赋值运算符；
- （）：函数调用运算符；
- [] ：下标运算符；
- ->：通过指针访问类成员的运算符。

|  +   |  -   |  *   |   /    |   %   |    ^     |
| :--: | :--: | :--: | :----: | :---: | :------: |
|  &   |  \|  |  ~=  |   !    |   =   |    <     |
|  >   |  +=  |  -=  |   *=   |  /=   |    %=    |
|  ^=  |  &=  | \|=  |   <<   | `>>`  |  `>>=`   |
| <<=  |  ==  |  !=  |   <=   | `>=`  |    &&    |
| \|\| |  ++  |  --  |   ,    |  ->*  |    ->    |
|  ()  |  []  | new  | delete | new[] | delete[] |



# 3. 友元

​	友元有三种：

- 友元函数；
- 友元类；
- 友元成员函数。



​	让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。

​	使用非成员重载运算符函数可以解决二元运算符交换操作数带来的问题，但是非成员函数不能直接访问类的私有数据。为此引入了 友元函数。

## 3.1 创建友元

​	创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字 friend：

```c++
friend Time operator*(double m, const Time & t); // goes in class declaration
```

​	该原型以为着下面两点：

- 虽然函数是在类声明中声明的，但不是成员函数，因此不能使用成员运算符来调用；
- 虽然函数不是成员函数，但与成员函数的访问权限相同。



​	第二步，编写函数定义。因为不是成员函数，所以不要使用 类限定符。另外，不要在定义中使用关键字 friend。

成员函数 <> 友元函数



# 4. 重载运算符：作为成员函数还是非成员函数（一般是友元）

​	非成员版本的重载运算符函数所需的型参数目与运算符使用的操作数目相同；成员版本所需的参数数目少一个，因为其中的一个操作数是被隐式地传递的调用对象。



# 6. 类的自动转换和强制类型转换

​	将一个标准类型变量的值赋给另一个标准类型的变量时，如果这两种类型兼容（比如都是数字），则C++自动将这个值转换为接收变量的类型。

​	C++ 语言不自动转换不兼容的类型。

​	在C++中，接收一个参数的构造函数为将类型与该参数相同的值转换类提供了蓝图。只有接受一个参数的构造函数才能作为转换函数。

​	C++新增关键字 explicit 关闭自动类型函数转换。	

```c++
explicit Stonewt(double lbs); // no implicit conversions allowed

Stonewt myCat; // create a Stonewt object
myCat = 19.6; // not valid if Stonewt(double) is declared as explicit mycat = Stonewt(19.6); // ok, an explicit conversion
mycat = (Stonewt) 19.6; // ok, old form for explicit typecast
```

## 6.1 转换函数

​	构造函数只用于从某种类型到类类型的转换。要进行相反的转换，必须使用特殊的C++ 运算符函数——转换函数（用户定义的强制类型转换，也可以由编译器来做转换）。

```C++
operator typeName(); // typename  为转换的类型  
```

​	注意以下几点：

- 转换函数必须是类方法；

- 转换函数不能指定返回类型；（在实现中又返回值）

- 转换函数不能有参数；

  在 C++98 中，关键字 explicit 不能用于转换函数，但C++11 消除了这种限制。



​	总之：C++为类提供了下面的类型转换

- 只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型。在构造函数声明中使用explicit可防止隐式转换，而只允许显示转化
- 被称为转换函数的特殊类成员运算符函数，用于将类对象转换为其他类型。转换函数是类成员，没有返回类型、没有参数，名称 operator typeName（），其中，typeName 是对象将被转换成的类型。将类对象赋给typeName 变量或其他强子转换为typeName 类型时，该转换函数将自动被调用。



​	



