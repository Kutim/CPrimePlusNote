

​	不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存。对于静态成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员变量是单独存储的，而不是对象的组成部分。请注意初始化语句指出了类型，并使用了作用域运算符，但没有使用关键字 static。

​	但如果静态成员时整型或枚举型 const ，则可以在类声明中初始化。

​	当使用一个对象来初始化另一个对象时，编译器将自动生成一个构造函数（称为赋值构造函数，因为他创建对象的一个副本）

# 1. 特殊成员函数

​	C++ 自动提供下面成员函数：

- 默认构造函数，如果没有定义构造函数；

- 默认析构函数，如果没有定义；

- 复制构造函数，如果没有定义；

  用户将一个对象复制到新创建的对象中。也就是说，它用于初始化过程中（包括按值传递参数），而不是常规的复制过程中。类的复制构造函数原型通常如下：

  ```c++
  Class_name(const Class_name &);
  ```

  新建一个对象并对其初始化为同类现有对象时，复制构造函数都将被调用。

  每当程序生成对象副本时，编译器都将使用复制构造函数。具体地说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。

  默认的复制构造函数逐个复制非静态成员（成员复制也称为浅复制），复制的是成员的值。

  如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。

  如果类中包含静态数据成员，应该提供一个显示复制构造函数来处理静态数据成员。

  必须定义复制构造函数的原因在于，一些类成员是使用new 初始化的、指向数据的指针，而不是数据本身。

- 赋值运算符，如果没有定义；

  ANSI C允许结构赋值，C++允许类对象赋值，这是通过自动类重载赋值运算符实现的。

  ```c++
  Class_name & Class_name::operator=(const Class_name &);
  ```

  将已有的对象赋给另一个对象时，将使用重载的复制运算符。

  - 由于目标对象可能引用了以前分配的数据，所以函数应使用 delete（）来释放这些数据
  - 函数应当避免将对象赋给自身；否则给对象重新复制前，释放内存操作可能删除对象的内容
  - 函数返回一个指向调用对象的引用。

  ```c++
  StringBad & StringBad::operator=(const StringBad & st)
  {
  	if (this == &st) 				// object assigned to itself
  		return *this;				// all done
  	delete [] str;					// free old string
  	len = st.len;					
  	str = new char [len + 1]; 		// get space for new string
  	std::strcpy(str, st.str); 		// copy the string
  	return *this;					// return reference to invoking object
  }
  ```

  ​

- 地址运算符，如果没有定义。



​	C++ 11 提供了另外两个特殊成员函数：移动构造函数和移动赋值运算符——见18章



​	C++11 引入新关键字 nullptr，用于表示空指针。

​	在重载时，C++将区分常量和非常量函数的特征标。



# 3. 在构造函数中使用 new 时应注意的事项

- 如果在构造函数中使用 new 来初始化指针成员，则应在析构函数中使用 delete；
- new 和 delete 必须相互兼容。new 对应于 delete，new[] 对应于 delete[]；
- 如果有多个构造函数，则必须以相同的方式 使用 new，要么都带中括号，要么都不带。因为只有一个析构函数，所有的构造函数都必须与它兼容。
- 应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。应分配足够的空间来存储复制的数据，并赋值数据。
- 应当定义一个赋值运算符，通过深度复制将一个对象赋值给另一个对象。

# 4. 有关返回对象的说明

​	如果方法或函数要返回局部对象，则应返回对象。而不是指向对象的引用。

​	如果方法或函数要返回一个没有公有复制构造函数的类的对象，它必须返回一个指向这种的引用。

​	有些方法和函数可以返回对象，也可以返回指向对象的引用，在这种情况下，应首选引用，提高效率。

## 4.1 返回指向 const 对象的引用

- 返回对象将调用赋值构造函数，而返回引用不会；
- 引用指向的对象应该在调用函数执行时存在；

## 4.2 返回指向非 const对象的引用

## 4.3 返回对象

## 4.4 返回 const 对象



# 5. 指向对象的指针



​	通常，如果 Class_name 是类，value 的类型为 Type_name，则下面的语句：

```c++
Class_name * pclass = new Class_name(value);
// 调用如下构造函数
Class_name(Type_name);
// 可能还有一些转换
Class_name(const Type_name &);
```



- 如果对象是动态变量，则当执行完定义该对象的程序时，将调用该对象的析构函数。
- 如果对象是静态变量，则在程序结束时将调用对象的析构函数。
- 如果对象是用 new 创建的，则仅当显示的使用 delete 删除对象时，其析构函数才会被调用。



指针和对象小结：

- 使用常规表示法来声明指向对象的指针；

  ```c++
  String * glamour;
  ```

- 可以将指针初始化为指向已有的对象

  ```c++
  String * first = &sayings[0];
  ```

- 可以使用new 来初始化指针，这将创建一个新的对象

  ```c++
  String * favorite = new String(sayings[choice]);
  ```

- 对类使用 new 将调用相应的类构造函数来初始化新创建的对象

- 可以使用 -> 运算符通过指针访问类方法

- 可以通过对象指针应用解除引用运算符（*）来获得对象



定位 new 运算符：delete 可与常规 new 运算符配合使用，但不能与定位new 运算符配合使用。可以显示为使用定位new 运算符创建的对象调用析构函数。



# 6. 技术总结

## 6.1 重载 << 运算符

​	重新定义 << 运算符，以便将它和 cout一起用来显示对象的内容。

```c++
ostream & operator<<(ostream & os, const c_name & obj)
{
	os << ... ; // display object contents
	return os;
}
```

## 6.2 转换函数

```c++
c_name(type_name value);

operator type_name();
```

## 6.3 构造函数使用 new 的类

- 对于指向的内存是由 new 分配的所有类成员，都应在类的析构函数中对其使用 delete，改运算符将释放分配的内存；

- 如果析构函数通过对指针类成员使用 delete 来释放内存，则每个构造函数都应当使用 new来初始化指针，或将它设置为空指针；

- 构造函数中要么使用 new[] ，要么使用  new，而不能混用。如果构造函数使用的是 new[]，则析构函数应使用delete[]；如果构造函数使用的是 new，则析构函数应使用delete。

- 应定义一个分配内存（而不是将指针指向已有内存）的复制构造函数。这样程序将能够将类对象初始化为另一个类对象。

  ```c++
  className(const className &)
  ```

- 应定义一个重载赋值运算符的类成员函数，其函数定义如下

  ```c++
  c_name & c_name::operator=(const c_name & cn)
  ```



# 7.

## 成员初始化列表- 用于构造函数

```c++
Classy::Classy(int n, int m) :mem1(n), mem2(0), mem3(n*m + 2) {
//...
}
```

​	这些初始化工作是在对象创建时完成的，此时未执行括号中的任何代码

​	注意：

- 这种格式只能用于构造函数；
- 必须用这种格式初始化非静态 const 数据成员（至少在 C++11 之前是这样的）；
- 必须用这种格式来初始化引用数据成员
- 数据成员被初始化的顺序与它们出现在类声明中的顺序相同，与初始化器中的排列顺序无关



​	成员初始化列表使用的括号方式也可用于常规初始化。这使得初始化内置类型就像初始化类对象一样。



​	C++11 允许以更直观的方式进行初始化：

```c++
class Classy {
	int mem1 = 10; // in-class initialization 
	const int mem2 = 20; // in-class initialization
	//... 
};

// 与在构造函数中使用成员初始化列表等价
Classy::Classy() : mem1(10), mem2(20) {...}
```

